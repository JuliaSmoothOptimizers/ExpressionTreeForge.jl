var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ExpressionTreeForge, M_abstract_expr_tree, M_trait_expr_tree, M_interface_expr_tree, M_implementation_expr_tree_Expr, M_implementation_expr_tree, M_implementation_complete_expr_tree, M_evaluation_expr_tree, M_bound_propagations, M_convexity_detection, algo_expr_tree, M_trait_expr_node, M_interface_expr_node, M_variable, M_times_operator, M_tan_operator, M_sinus_operator, M_simple_operator, M_power_operator, M_plus_operator, M_minus_operator, M_frac_operator, M_exp_operator, M_cos_operator, M_constant, M_abstract_expr_node, M_trait_tree, algo_tree, M_interface_tree, M_implementation_tree, M_implementation_tree_Expr, M_abstract_tree, M_trait_type_expr, M_interface_type_expr, M_implementation_type_expr, M_implementation_convexity_type]","category":"page"},{"location":"reference/#ExpressionTreeForge.Complete_expr_tree","page":"Reference","title":"ExpressionTreeForge.Complete_expr_tree","text":"Complete_expr_tree{T} <: AbstractTree\n\nImplementation of an expression tree. Complete_expr_tree is the same than Type_expr_tree with the additions in each node of a Bounds and Convexity_wrapper. A Complete_expr_tree has fields:\n\nfield::Complete_node{T} representing an operator, a constant or a variable alongide its bounds and its convexity status;\nchildren::Vector{Complete_expr_tree{T}} a vector of children, each of them being a Complete_expr_tree{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.Type_calculus_tree","page":"Reference","title":"ExpressionTreeForge.Type_calculus_tree","text":"Type_calculus_tree\n\nRepresent the different types that a expression can be :\n\nconstant\nlinear\nquadratic\ncubic\nmore which means non-linear, non-quadratic and non-cubic. \n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.Type_expr_tree","page":"Reference","title":"ExpressionTreeForge.Type_expr_tree","text":"Type_expr_tree{T} <: AbstractTree\n\nBasic implementation of an expression tree. Every expression tree supported must be able to return Type_expr_tree. A Type_expr_tree has fields:\n\nfield::Abstract_expr_node representing an operator, a constant or a variable;\nchildren::Vector{Type_expr_tree{T}} a vector of children, each of them being a Type_expr_tree{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.Type_node","page":"Reference","title":"ExpressionTreeForge.Type_node","text":"Type_node{T} <: AbstractTree\n\nBasic implementation of a tree. A Type_node has fields:\n\nfield gathering the informations about the current node;\nchildren a vector of children, each of them being a Type_node.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.cast_type_of_constant-Tuple{Any, DataType}","page":"Reference","title":"ExpressionTreeForge.cast_type_of_constant","text":"cast_type_of_constant(expr_tree, type::DataType)\n\nCast to type the constants of expr_tree. expr_tree may be an Expr, a Type_expr_tree or a Complete_expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.complete_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.complete_tree","text":"complete_tree = complete_tree(expression_tree::Type_expr_tree)\n\nCreate a complete_tree::Complete_expr_tree from expression_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.concave_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.concave_type","text":"concave = concave_type()\n\nReturn the value of concave from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.constant_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.constant_type","text":"constant = constant_type()\n\nReturn the value of constant from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.convex_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.convex_type","text":"convex = convex_type()\n\nReturn the value of convex from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.create_bounds_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.create_bounds_tree","text":"bound_tree = create_bounds_tree(tree)\n\nReturn a similar expression tree to tree, where each node has an undefined bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.create_convex_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.create_convex_tree","text":"convex_tree = create_convex_tree(tree::Type_expr_tree)\n\nReturn a similar expression tree to tree, where each node has an undefined convexity status.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.evaluate_expr_tree-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.evaluate_expr_tree","text":"evaluate_expr_tree(expr_tree::Type_expr_tree, x::AbstractVector)\nevaluate_expr_tree(expr_tree::Complete_expr_tree, x::AbstractVector)\n\nEvaluate the expr_tree given the vector x.\n\nExample:\n\njulia> evaluate_expr_tree(:(x[1] + x[2]), ones(2))\n2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.evaluate_expr_tree_multiple_points-Tuple{Any, AbstractVector}","page":"Reference","title":"ExpressionTreeForge.evaluate_expr_tree_multiple_points","text":"evaluate_expr_tree_multiple_points(expression_tree::Any, x::AbstractVector{AbstractVector}})\nevaluate_expr_tree_multiple_points(expression_tree::Any)\n\nEvaluate the expression_tree with several points, represented as x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.extract_element_functions-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.extract_element_functions","text":"separated_terms = extract_element_functions(expr_tree)\n\nReturn the element functions of expr_tree as a vector of its subexpression. expr_tree may be an Expr, a Type_expr_tree or a Complete_expr_tree.\n\nExample:\n\njulia> extract_element_functions(:(x[1] + x[2] + x[3]*x[4] ) )\n3-element Vector{Expr}:\n :(x[1])\n :(x[2])\n :(x[3] * x[4])\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_Ui-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"ExpressionTreeForge.get_Ui","text":"Ui = get_Ui(indices::Vector{Int}, n::Int)\n\nCreate a sparse matrix Ui from indices computed by get_elemental_variables. Every index i (of indices) form a line of Ui corresponding to i-th Euclidian vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_bounds-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.get_bounds","text":"(inf_bound, sup_bound) = get_bounds(bound_tree::Bound_tree)\n\nRetrieve the bounds of the root of bound_tree, the bounds of expression tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_convexity_status-Tuple{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper}}","page":"Reference","title":"ExpressionTreeForge.get_convexity_status","text":"convexity_status = get_convexity_status(convexity_tree::M_convexity_detection.Convexity_tree)\nconvexity_status = get_convexity_status(complete_tree::Complete_expr_tree)\n\nReturn the convexity status of either convexity_tree or complete_tree. The status can be:\n\nconstant\nlinear\nconvex\nconcave\nunknown\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_elemental_variables-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.get_elemental_variables","text":"indices = get_elemental_variables(expr_tree)\n\nReturn the indices of the variable appearing in expr_tree. This function is used to find the elemental variables from the expression tree of an element function. expr_tree may be an Expr, a Type_expr_tree or a Complete_expr_tree.\n\nExample:\n\njulia> get_elemental_variables(:(x[1] + x[3]) )\n[1, 3]\njulia> get_elemental_variables(:(x[1]^2 + x[6] + x[2]) )\n[1, 6, 2]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_expression_tree-Tuple{NLPModelsJuMP.MathOptNLPModel}","page":"Reference","title":"ExpressionTreeForge.get_expression_tree","text":"expr = get_expression_tree(adnlp::MathOptNLPModel)\nexpr = get_expression_tree(adnlp::ADNLPModel)\nexpr = get_expression_tree(model::JuMP.Model)\n\nReturn the objective function as a Type_expr_tree for a: MathOptNLPModel, ADNLPModelJuMP.Model`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_function_of_evaluation-Tuple{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}","page":"Reference","title":"ExpressionTreeForge.get_function_of_evaluation","text":"eval_expression_tree = get_function_of_evaluation(expression_tree::Type_expr_tree)\n\nReturn and evaluation function of expression_tree with better performance than the actual evaluate_expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.get_type_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.get_type_tree","text":"type = get_type_tree(expr_tree)\n\nReturn the type of expr_tree. It can either be: constant, linear, quadratic, cubic or more. expr_tree may be an Expr, a Type_expr_tree or a Complete_expr_tree.\n\nExample:\n\njulia> get_type_tree(:(5+4)) == constant\ntrue\njulia> get_type_tree(:(x[1])) == linear\ntrue\njulia> get_type_tree(:(x[1]* x[2])) == quadratic\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.gradient_forward-Tuple{Any, AbstractVector}","page":"Reference","title":"ExpressionTreeForge.gradient_forward","text":"gradient = gradient_forward(expr_tree, x)\n\nEvaluate the gradient of expr_tree at the point x with a forward automatic differentiation method.\n\nExample:\n\njulia> gradient_forward(:(x[1] + x[2]), rand(2))\n[1.0 1.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.gradient_reverse-Tuple{Any, AbstractVector}","page":"Reference","title":"ExpressionTreeForge.gradient_reverse","text":"gradient = gradient_reverse(expr_tree, x)\n\nEvaluate the gradient of expr_tree at the point x with a reverse automatic differentiation method.\n\nExample:\n\njulia> gradient_reverse(:(x[1] + x[2]), rand(2))\n[1.0 1.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.hessian-Tuple{Any, AbstractVector}","page":"Reference","title":"ExpressionTreeForge.hessian","text":"hess = hessian(expr_tree, x)\n\nEvaluate the Hessian of expr_tree at the point x with forward automatic differentiation.\n\nExample:\n\njulia> hessian(:(x[1]^2 + x[2]), rand(2))\n[2.0 0.0; 0.0 0.0]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_concave-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_concave","text":"bool = is_concave(status::Convexity_type)\nbool = is_concave(convexity::Convexity_wrapper)\n\nCheck if convexity_status is concave.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_constant-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_constant","text":"bool = is_constant(status::Convexity_type)\nbool = is_constant(convexity::Convexity_wrapper)\n\nCheck if convexity_status is constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_constant-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.is_constant","text":"bool = is_constant(type::Type_calculus_tree)\n\nCheck if type have the value constant from the enumerative type Type_calculus_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_convex-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_convex","text":"bool = is_convex(status::Convexity_type)\nbool = is_convex(convexity::Convexity_wrapper)\n\nCheck if convexity_status is convex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_cubic-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.is_cubic","text":"bool = is_cubic(type::Type_calculus_tree)\n\nCheck if type have the value cubic from the enumerative type Type_calculus_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_linear-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_linear","text":"bool = is_linear(status::Convexity_type)\nbool = is_linear(convexity::Convexity_wrapper)\n\nCheck if convexity_status is linear.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_linear-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.is_linear","text":"bool = is_linear(type::Type_calculus_tree)\n\nCheck if type have the value linear from the enumerative type Type_calculus_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_more-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.is_more","text":"bool = is_more(type::Type_calculus_tree)\n\nCheck if type have the value more from the enumerative type Type_calculus_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_not_treated-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_not_treated","text":"bool = is_not_treated(status::Convexity_type)\nbool = is_not_treated(convexity::Convexity_wrapper)\n\nCheck if convexity_status is not_treated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_quadratic-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.is_quadratic","text":"bool = is_quadratic(type::Type_calculus_tree)\n\nCheck if type have the value quadratic from the enumerative type Type_calculus_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_treated-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_treated","text":"bool = is_treated(status::Convexity_type)\nbool = is_treated(convexity::Convexity_wrapper)\n\nCheck if convexity_status is different of not_treated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.is_unknown-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.is_unknown","text":"bool = is_unknown(status::Convexity_type)\nbool = is_unknown(convexity::Convexity_wrapper)\n\nCheck if convexity_status is unknown.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.linear_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.linear_type","text":"linear = linear_type()\n\nReturn the value of linear from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.normalize_indices!-Tuple{Any, AbstractVector{Int64}}","page":"Reference","title":"ExpressionTreeForge.normalize_indices!","text":"normalize_indices!(expr_tree, vector_indices::Vector{Int})\n\nChange the indices of the variables of expr_tree given the order given by vector_indices. It it paired with get_elemental_variables to define the elemental element functions expression tree. expr_tree may be an Expr, a Type_expr_tree or a Complete_expr_tree.\n\nExample:\n\njulia> normalize_indices!(:(x[4] + x[5]), [4,5])\n:(x[1] + x[2])\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.print_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.print_tree","text":"print_tree(tree::AbstractTree)\n\nPrint a tree as long as it satisfies the interface M_interface_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.set_bounds!-Tuple{Any, Any}","page":"Reference","title":"ExpressionTreeForge.set_bounds!","text":"set_bounds!(tree::Type_expr_tree, bound_tree::Bound_tree)\nset_bounds!(complete_tree::Complete_expr_tree)\n\nSet the bounds of bound_tree by walking tree and propagate the computation from the leaves to the root. A Complete_expr_tree contains a precompiled bound_tree, and then can be use alone.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.set_convexity!-Tuple{Any, Any, Any}","page":"Reference","title":"ExpressionTreeForge.set_convexity!","text":"set_convexity!(tree::Type_expr_tree, convexity_tree::Convexity_tree, bound_tree::Bound_tree)\nset_convexity!(complete_tree::Complete_expr_tree)\n\nDeduce from elementary rules the convexity status of tree nodes or complete_tree nodes. complete_tree integrate a bounds tree and can run alone the convexity detection whereas tree  require the bound_tree (see create_bounds_tree) and convexity_tree (see create_convex_tree).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.transform_to_Expr-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.transform_to_Expr","text":"expr = transform_to_Expr(expr_tree)\n\nTransform expr_tree into an Expr. expr_tree may be a Type_expr_tree or a Complete_expr_tree. Warning: This function return an Expr with variables as MathOptInterface.VariableIndex. In order to get an standard Expr use transform_to_Expr_julia.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.transform_to_Expr_julia-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.transform_to_Expr_julia","text":"expr = transform_to_Expr_julia(expr_tree)\n\nTransform expr_tree into an Expr. expr_tree may be a Type_expr_tree or a Complete_expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.transform_to_expr_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.transform_to_expr_tree","text":"expr_tree = transform_to_expr_tree(expr::Expr)\n\nTransform expr into an expr_tree::Type_expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.unknown_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.unknown_type","text":"unknown = unknown_type()\n\nReturn the value of unknown from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree","text":"Supertype of every expression tree. \n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.Bounds","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.Bounds","text":"Bounds{T <: Number}\n\nStructure representing the upper-bound and the lower-bound of a node. \n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.create_Expr-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.create_Expr","text":"expr = create_expr_tree(tree)\n\nCreate an Expr from tree. tree can be several types. For now, it supports Expr and ModelingToolkit.Operation, as well as the internal expression trees defined. The variables of the Expr use MathOptInterface variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.create_Expr2-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.create_Expr2","text":"expr = create_expr_tree(tree)\n\nCreate a julia Expr from tree. tree can be several types. For now, it supports Expr and ModelingToolkit.Operation, as well as the internal expression trees defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.create_empty_bounds-Tuple{DataType}","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.create_empty_bounds","text":"bound = create_empty_bounds(type::DataType)\n\nCreate a Bounds structure of type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.create_expr_tree-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.create_expr_tree","text":"expr_tree = create_expr_tree(tree)\n\nCreate an Type_expr_tree from tree. tree can be several types. For now, it supports Expr and ModelingToolkit.Operation, as well as the internal expression trees defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.get_bounds-Union{Tuple{ExpressionTreeForge.M_abstract_expr_tree.Bounds{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.get_bounds","text":"(inf_bound, sup_bound) = get_bounds(bound::Bounds{T}) where {T <: Number}\n\nRetrieve both inf_bound and sup_bound from bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_tree.set_bound!-Union{Tuple{T}, Tuple{ExpressionTreeForge.M_abstract_expr_tree.Bounds{T}, T, T}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_tree.set_bound!","text":"set_bound!(bound::Bounds{T}, inf_bound::T, sup_bound::T) where {T <: Number}\n\nSet bound to inf_bound and sup_bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.Is_expr_tree","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.Is_expr_tree","text":"Type instantiated dynamically checking that an argument is an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.Is_not_expr_tree","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.Is_not_expr_tree","text":"Type instantiated dynamically checking that an argument is not an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.expr_tree_equal","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.expr_tree_equal","text":"bool = expr_tree_equal(expr_tree1, expr_tree2, eq::Atomic{Bool} = Atomic{Bool}(true))\n\nCheck if expr_tree1 and expr_tree2 valued the same, by checking recursively their respective nodes. \n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.expr_tree_to_create-Tuple{Any, Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.expr_tree_to_create","text":"expr_tree = expr_tree_to_create(tree1::AbstractExprTree, tree2::AbstractExprTree)\n\nReturn expr_tree, a expression tree of the type from tree2 with the values of tree1. It is supported for few expression-tree structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.get_expr_children-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.get_expr_children","text":"children = get_expr_children(tree::AbstractExprTree)\n\nReturn the children of the root of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.get_expr_node-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.get_expr_node","text":"node = get_expr_node(tree::AbstractExprTree)\n\nReturn the node being the root of the tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.get_real_node-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.get_real_node","text":"_get_real_node(tree::AbstractExprTree)\n\nReturn the value of a leaf in a suitable format for particular algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.inverse_expr_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.inverse_expr_tree","text":"minus_tree = inverse_expr_tree(tree::AbstractExprTree)\n\nApply a unary minus on tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.is_expr_tree-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.is_expr_tree","text":"verifier_type = is_expr_tree(arg)\n\nReturn Is_expr_tree if arg is considered as an implementation of an expression tree, it returns Is_not_expr_tree otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.transform_to_Expr-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.transform_to_Expr","text":"expr = transform_to_Expr(expr_tree)\n\nReturn expr::Expr from the expression tree expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_tree.transform_to_expr_tree-Tuple{T} where T","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_tree.transform_to_expr_tree","text":"expr_tree = _transform_to_expr_tree(tree::AbstractExprTree)\n\nReturn expr_tree::Type_expr_tree from tree. Type_expr_tree is the internal expression tree structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._expr_tree_to_create-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree, ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._expr_tree_to_create","text":"expr_tree = _expr_tree_to_create(tree1::AbstractExprTree, tree2::AbstractExprTree)\n\nReturn expr_tree, a expression tree of the type from tree2 with the values of tree1. It is supported for few expression-tree structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._get_expr_children-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._get_expr_children","text":"children = _get_expr_children(tree::AbstractExprTree)\n\nReturn the children of the root of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._get_expr_node-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._get_expr_node","text":"node = _get_expr_node(tree::AbstractExprTree)\n\nReturn the node being the root of the tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._get_real_node-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._get_real_node","text":"_get_real_node(tree::AbstractExprTree)\n\nReturn the value of a leaf in a suitable format for particular algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._inverse_expr_tree-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._inverse_expr_tree","text":"minus_tree = _inverse_expr_tree(tree::AbstractExprTree)\n\nApply a unary minus on tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_tree._transform_to_expr_tree-Tuple{ExpressionTreeForge.M_abstract_expr_tree.AbstractExprTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_tree._transform_to_expr_tree","text":"expr_tree = _transform_to_expr_tree(tree::AbstractExprTree)\n\nReturn expr_tree::Type_expr_tree from tree. Type_expr_tree is the internal expression tree structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_expr_tree_Expr.Variable_counter","page":"Reference","title":"ExpressionTreeForge.M_implementation_expr_tree_Expr.Variable_counter","text":"Variable_counter\n\nAssociate the index of the symbol variable to their integer index.  \n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_expr_tree.Type_expr_tree","page":"Reference","title":"ExpressionTreeForge.M_implementation_expr_tree.Type_expr_tree","text":"Type_expr_tree{T} <: AbstractTree\n\nBasic implementation of an expression tree.Every expression tree supported must be able to returnTypeexprtree. ATypeexprtree` has fields:\n\nfield::Abstract_expr_node representing an operator, a constant or a variable;\nchildren::Vector{Type_expr_tree{T}} a vector of children, each of them being a Type_expr_tree{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_complete_expr_tree.Complete_expr_tree","page":"Reference","title":"ExpressionTreeForge.M_implementation_complete_expr_tree.Complete_expr_tree","text":"Complete_expr_tree{T} <: AbstractTree\n\nImplementation of an expression tree. Complete_expr_tree is the same than Type_expr_tree with the additions in each node of a Bounds and Convexity_wrapper. A Complete_expr_tree has fields:\n\nfield::Complete_node{T} representing an operator, a constant or a variable alongide its bounds and its convexity status;\nchildren::Vector{Complete_expr_tree{T}} a vector of children, each of them being a Complete_expr_tree{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_complete_expr_tree.Complete_node","page":"Reference","title":"ExpressionTreeForge.M_implementation_complete_expr_tree.Complete_node","text":"Complete_node{T <: Number}\n\nGather in a single structure:\n\nop::M_abstract_expr_node.Abstract_expr_node an arithmetic operator;\nbounds::M_abstract_expr_tree.Bounds{T} the bounds of this operator depending its children;\nconvexity_status::M_implementation_convexity_type.Convexity_wrapper the convexity status of this operator depending its children.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_evaluation_expr_tree.gradient_forward-Tuple{Any, Vector}","page":"Reference","title":"ExpressionTreeForge.M_evaluation_expr_tree.gradient_forward","text":"gradient_forward(expr_tree, x)\n\nEvaluate the gradient of the function represented by `expr_tree at the point x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_evaluation_expr_tree.hessian-Tuple{Any, Vector}","page":"Reference","title":"ExpressionTreeForge.M_evaluation_expr_tree.hessian","text":"hess = hessian(expr_tree, x)\n\nCompute the hessian matrix of the function represented by expr_tree at the point x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_bound_propagations.Bound_tree","page":"Reference","title":"ExpressionTreeForge.M_bound_propagations.Bound_tree","text":"Bound_tree\n\nA tree where each node is a pair (bound_inf, bound_sup). Must be paired with an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_bound_propagations.create_bounds_tree","page":"Reference","title":"ExpressionTreeForge.M_bound_propagations.create_bounds_tree","text":"bound_tree = create_bounds_tree(tree)\n\nReturn a similar expression tree to tree, where each node has an undefined bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_bound_propagations.get_bounds-Union{Tuple{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_tree.Bounds{T}}}, Tuple{T}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_bound_propagations.get_bounds","text":"(inf_bound, sup_bound) = get_bounds(bound_tree::Bound_tree)\n\nRetrieve the bounds of the root of bound_tree, the bounds of expression tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_bound_propagations.set_bounds!-Union{Tuple{T}, Tuple{ExpressionTreeForge.M_implementation_tree.Type_node, ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_tree.Bounds{T}}}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_bound_propagations.set_bounds!","text":"set_bounds!(tree, bound_tree::Bound_tree)\nset_bounds!(complete_tree::Complete_expr_tree)\n\nSet the bounds of bound_tree by walking tree and by propagating the computations from the leaves to the root. A Complete_expr_tree contains a precompiled bound_tree, and then can be use alone.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.Convexity_tree","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.Convexity_tree","text":"Convexity_tree\n\nA tree where each node is a convexity status. Must be paired with an expression tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.concave_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.concave_type","text":"concave = concave_type()\n\nReturn the value concave from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.constant_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.constant_type","text":"constant = constant_type()\n\nReturn the value constant from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.convex_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.convex_type","text":"convex = convex_type()\n\nReturn the value convex from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.create_convex_tree-Tuple{ExpressionTreeForge.M_implementation_tree.Type_node}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.create_convex_tree","text":"convex_tree = create_convex_tree(tree::Type_node)\n\nReturn a similar expression tree to tree, where each node has an undefined convexity status.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.get_convexity_status-Tuple{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper}}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.get_convexity_status","text":"convexitystatus = getconvexitystatus(convexitytree::Mconvexitydetection.Convexitytree)   convexitystatus = getconvexitystatus(completetree::Mimplementationcompleteexprtree.Completeexpr_tree)\n\nReturn the convexity status of either convexity_tree or complete_tree. The status can be:\n\nconstant\nlinear\nstrictly convex\nstrictly concave\nunknown\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.linear_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.linear_type","text":"linear = linear_type()\n\nReturn the value linear from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.set_convexity!-Tuple{ExpressionTreeForge.M_implementation_tree.Type_node, ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper}, Any}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.set_convexity!","text":"set_convexity!(tree, convexity_tree, bound_tree)\nset_convexity!(complete_tree)\n\nDeduce from elementary rules the convexity status of tree nodes or complete_tree nodes. complete_tree integrate a bounds tree and can run alone the convexity detection whereas tree require the bound_tree (see create_bounds_tree) and convexity_tree (see create_convex_tree).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_convexity_detection.unknown_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_convexity_detection.unknown_type","text":"unknown = unknown_type()\n\nReturn the value unknown from the enumerative type M_implementation_convexity_type.Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.N_to_Ni-Tuple{Vector{Int64}}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.N_to_Ni","text":"dic = N_to_Ni(elemental_var::Vector{Int})\n\nReturn a dictionnary informing the index changes of an element expression tree. If element_var = [4,5] then dic == Dict([4=>1, 5=>2]).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.cast_type_of_constant-Tuple{Any, DataType}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.cast_type_of_constant","text":"cast_type_of_constant(expr_tree, type::DataType)\n\nCast to type the constants of expr_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.extract_element_functions-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.extract_element_functions","text":"separated_terms = extract_element_functions(expr_tree)\n\nDivide the expression tree as a terms of a sum if possible. It returns a vector where each component is a subexpression tree of expr_tree.\n\nExample:\n\njulia> extract_element_functions(:(x[1] + x[2] + x[3]*x[4] ) )\n3-element Vector{Expr}:\n :(x[1])\n :(x[2])\n :(x[3] * x[4])\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.get_Ui-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.get_Ui","text":"Ui = get_Ui(indices::Vector{Int}, n::Int)\n\nCreate a sparse matrix Ui from indices computed by get_elemental_variables. Every index i (of indices) form a line of Ui corresponding to i-th Euclidian vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.get_elemental_variables-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.get_elemental_variables","text":"indices = get_elemental_variables(expr_tree)\n\nReturn the indices of the variable appearing in expr_tree. This function find the elemental variables from the expression tree of an element function.\n\nExample:\n\njulia> get_elemental_variables(:(x[1] + x[3]) )\n[1, 3]\njulia> get_elemental_variables(:(x[1]^2 + x[6] + x[2]) )\n[1, 6, 2]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.get_type_tree-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.get_type_tree","text":"type = get_type_tree(expr_tree)\n\nReturn the type of expr_tree. It can either be: constant, linear, quadratic, cubic or more.\n\nExample:\n\njulia> get_type_tree(:(5+4)) == constant\ntrue\njulia> get_type_tree(:(x[1])) == linear\ntrue\njulia> get_type_tree(:(x[1]* x[2])) == quadratic\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_expr_tree.normalize_indices!-Tuple{Any, Vector{Int64}}","page":"Reference","title":"ExpressionTreeForge.algo_expr_tree.normalize_indices!","text":"normalize_indices!(expr_tree, vector_indices)\n\nChange the indices of the variables of expr_tree given the order given by vector_indices. It it paired with get_elemental_variables to define the elemental element functions expression tree.\n\nExample:\n\njulia> normalize_indices!(:(x[4] + x[5]), [4,5])\n:(x[1] + x[2])\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.Type_expr_node","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.Type_expr_node","text":"Type instantiated dynamically checking that an argument is an expression node.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.Type_not_expr_node","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.Type_not_expr_node","text":"Type instantiated dynamically checking that an argument is a not an expression node.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.cast_constant!-Tuple{Any, DataType}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.cast_constant!","text":"bool = cast_constant!(node::Abstract_expr_node, type::Datatype)\n\nRewrite the Numbers composing node as type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.change_from_N_to_Ni!-Tuple{Any, Dict{Int64, Int64}}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.change_from_N_to_Ni!","text":"change_from_N_to_Ni!(node::Abstract_expr_node, dic_new_indices::Dict{Int, Int})\n\nChange the index of the variables following the index given by dic_new_indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.evaluate_node-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.evaluate_node","text":"value = _evaluate_node(node::Abstract_expr_node, value_children::AbstractVector{T}) where T<:Number\n\nEvaluate node depending value_children.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.get_type_node-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.get_type_node","text":"type = get_type_node(node::Abstract_expr_node, children_types::AbstractVector{Type_expr_basic})\n\nReturn the type of node given the type of its children children_types. The types avaible areconstant, linear, quadratic, cubic or more.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.get_var_index-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.get_var_index","text":"index = get_var_index(variable::Abstract_expr_node)\n\nReturn the index of the variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_bound-Tuple{Any, DataType}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_bound","text":"(lowerbound, upper_bound) = node_bound(node::Abstract_expr_node, children_bounds::AbstractVector{Tuple{T, T}}, type::DataType)\n\nReturn the bounds of node given the children_bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_convexity-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_convexity","text":"bool = _node_is_operator(node::Abstract_expr_node, children_convex_status::AbstractVector{M_implementation_convexity_type.Convexity_type})\n\nReturn the convexity status of node given the children_convex_status.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_constant-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_constant","text":"bool = node_is_constant(node::Abstract_expr_node)\n\nCheck if node is a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_cos-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_cos","text":"bool = node_is_cos(node::Abstract_expr_node)\n\nCheck if node is a cos operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_minus-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_minus","text":"bool = node_is_minus(node::Abstract_expr_node)\n\nCheck if node is a - operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_operator-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_operator","text":"bool = node_is_operator(node::Abstract_expr_node)\n\nCheck if node is an operator. It could be also a variable or a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_plus-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_plus","text":"bool = node_is_plus(node::Abstract_expr_node)\n\nCheck if node is a + operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_power-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_power","text":"bool = node_is_power(node::Abstract_expr_node)\n\nCheck if node is a ^ operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_sin-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_sin","text":"bool = node_is_sin(node::Abstract_expr_node)\n\nCheck if node is a sin operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_tan-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_tan","text":"bool = node_is_tan(node::Abstract_expr_node)\n\nCheck if node is a tan operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_times-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_times","text":"bool = _node_is_times(node::Abstract_expr_node)\n\nCheck if node is a * operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_is_variable-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_is_variable","text":"bool = _node_is_variable(node::Abstract_expr_node)\n\nCheck if node is a variable. It could be also an operator or a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_to_Expr-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_to_Expr","text":"bool = node_to_Expr(node::Abstract_expr_node)\n\nReturn the information required to build later on a julia Expr. An operator return the operator symbol (ex: + -> :+). A variable return a variable as a MathOptInterface variable. A constant return its value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_expr_node.node_to_Expr2-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_expr_node.node_to_Expr2","text":"bool = node_to_Expr2(node::Abstract_expr_node)\n\nReturn the information required to build later on a julia Expr. An operator return the operator symbol (ex: + -> :+). A variable return a variable. A constant return its value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._cast_constant!-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._cast_constant!","text":"bool = _cast_constant!(node::Abstract_expr_node, type::Datatype)\n\nRewrite the Numbers composing node as type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._change_from_N_to_Ni!-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._change_from_N_to_Ni!","text":"_change_from_N_to_Ni!(node::Abstract_expr_node, dic_new_indices::Dict{Int, Int})\n\nChange the index of the variables following the index given by dic_new_indices. Must be implemented for leaf nodes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._evaluate_node!-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._evaluate_node!","text":"_evaluate_node!(node::Abstract_expr_node, value_children::AbstractVector{T}, ref::MyRef{T}) where T<:Number\n\nEvaluate node depending value_children and store the result in ref.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._evaluate_node-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._evaluate_node","text":"value = _evaluate_node(node::Abstract_expr_node, value_children::AbstractVector{T}) where T<:Number\n\nEvaluate node depending value_children.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._get_type_node-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._get_type_node","text":"type = _get_type_node(node::Abstract_expr_node, children_types::AbstractVector{Type_expr_basic})\n\nReturn the type of node given the type of its children children_types. The types available are constant, linear, quadratic, cubic or more.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._get_var_index-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._get_var_index","text":"index = _get_var_index(variable::Abstract_expr_node)\n\nReturn the index of the variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_bound-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_bound","text":"(lowerbound, upper_bound) = _node_bound(node::Abstract_expr_node, children_bounds::AbstractVector{Tuple{T, T}}, type::DataType)\n\nReturn the bounds of node given the children_bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_convexity-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_convexity","text":"bool = _node_is_operator(node::Abstract_expr_node, children_convex_status::AbstractVector{M_implementation_convexity_type.Convexity_type})\n\nReturn the convexity status of node given the children_convex_status.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_constant-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_constant","text":"bool = _node_is_constant(node::Abstract_expr_node)\n\nCheck if node is a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_cos-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_cos","text":"bool = _node_is_cos(node::Abstract_expr_node)\n\nCheck if node is a cos operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_minus-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_minus","text":"bool = _node_is_minus(node::Abstract_expr_node)\n\nCheck if node is a - operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_operator-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_operator","text":"bool = _node_is_operator(node::Abstract_expr_node)\n\nCheck if node is an operator. It could be also a variable or a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_plus-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_plus","text":"bool = _node_is_plus(node::Abstract_expr_node)\n\nCheck if node is a + operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_power-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_power","text":"bool = _node_is_power(node::Abstract_expr_node)\n\nCheck if node is a ^ operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_sin-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_sin","text":"bool = _node_is_sin(node::Abstract_expr_node)\n\nCheck if node is a sin operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_tan-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_tan","text":"bool = _node_is_tan(node::Abstract_expr_node)\n\nCheck if node is a tan operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_times-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_times","text":"bool = _node_is_times(node::Abstract_expr_node)\n\nCheck if node is a * operator or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_is_variable-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_is_variable","text":"bool = _node_is_variable(node::Abstract_expr_node)\n\nCheck if node is a variable. It could be also an operator or a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_to_Expr-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_to_Expr","text":"bool = _node_to_Expr(node::Abstract_expr_node)\n\nReturn the information required to build later on a julia Expr. An operator return the operator symbol (ex: + -> :+). A variable return a variable as a MathOptInterface variable. A constant return its value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_expr_node._node_to_Expr2-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_interface_expr_node._node_to_Expr2","text":"bool = _node_to_Expr2(node::Abstract_expr_node)\n\nReturn the information required to build later on a julia Expr. An operator return the operator symbol (ex: + -> :+). A variable return a variable. A constant return its value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node","text":"Supertype of every node. \n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.MyRef","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.MyRef","text":"MyRef{Y <: Number}\n\nSort of pointer. Contain the field:\n\nvalue which points to the desired structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.create_new_vector_myRef","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.create_new_vector_myRef","text":"vector_myref = create_new_vector_myRef(n::Int, type::DataType = Float64)\n\nCreate a vector of n myRef{type} components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.create_node_expr-Tuple{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.create_node_expr","text":"create_node_expr(arg::UnionAll)\n\nCreate a node from arg. See the different implementation in the src/node_expr_tree/impl_operators.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.create_undef_array_myRef","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.create_undef_array_myRef","text":"my_ref_matrix = create_undef_array_myRef(n::Int, m::Int, type::DataType = Float64)\n\nCreate a n×m array composed of myRef{type} components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.create_vector_of_vector_myRef","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.create_vector_of_vector_myRef","text":"vector_vector_myref = create_undef_array_myRef(l::Int, c::Int, type::DataType = Float64)\n\nCreate a vector of size l, each component is a Vector{myRef{type}} of c components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.equalize_vec_vec_myRef!-Union{Tuple{T}, Tuple{Array{Array{ExpressionTreeForge.M_abstract_expr_node.MyRef{T}, 1}, 1}, Array{Array{ExpressionTreeForge.M_abstract_expr_node.MyRef{T}, 1}, 1}}} where T<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.equalize_vec_vec_myRef!","text":"equalize_vec_vec_myRef!(a::Vector{Vector{MyRef{T}}}, b::Vector{Vector{MyRef{T}}}) where {T <: Number}\n\nSet the references of b to those of a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.get_myRef-Union{Tuple{ExpressionTreeForge.M_abstract_expr_node.MyRef{Y}}, Tuple{Y}} where Y<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.get_myRef","text":"value = get_myRef(reference::MyRef{Y}) where {Y <: Number}\n\nGet the value of the reference.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.new_ref-Tuple{Y} where Y<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.new_ref","text":"myref = new_ref(value::Y) where {Y <: Number}\nmyref = new_ref(type::DataType)\n\nCreate a new reference myRef from value or type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_expr_node.set_myRef!-Union{Tuple{Y}, Tuple{ExpressionTreeForge.M_abstract_expr_node.MyRef{Y}, Y}} where Y<:Number","page":"Reference","title":"ExpressionTreeForge.M_abstract_expr_node.set_myRef!","text":"set_myRef!(reference::MyRef{Y}, value::Y) where {Y <: Number}\n\nSet the reference to value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_tree.Type_not_trait_tree","page":"Reference","title":"ExpressionTreeForge.M_trait_tree.Type_not_trait_tree","text":"Type instantiated dynamically checking that an argument is not a tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_tree.Type_trait_tree","page":"Reference","title":"ExpressionTreeForge.M_trait_tree.Type_trait_tree","text":"Type instantiated dynamically checking that an argument is a tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_interface_tree._get_children-Tuple{Any, ExpressionTreeForge.M_trait_tree.Type_trait_tree}","page":"Reference","title":"ExpressionTreeForge.M_interface_tree._get_children","text":"children = _get_children(tree, trait_tree)\n\nGet the children from the current node as part of tree, if trait_tree::Type_trait_tree..\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_tree._get_node-Tuple{Any, ExpressionTreeForge.M_trait_tree.Type_trait_tree}","page":"Reference","title":"ExpressionTreeForge.M_interface_tree._get_node","text":"node = _get_node(tree, trait_tree)\n\nGet the current node as a part of tree, if trait_tree::Type_trait_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_tree.get_children-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_tree.get_children","text":"children = get_children(tree)\n\nGet the children from the current node as part of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_tree.get_node-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_tree.get_node","text":"node = get_node(tree)\n\nGet the current node as a part of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_tree.is_type_trait_tree-Tuple{ExpressionTreeForge.M_abstract_tree.AbstractTree}","page":"Reference","title":"ExpressionTreeForge.M_trait_tree.is_type_trait_tree","text":"Type_trait_tree = is_type_trait_tree(a::AbstractTree)\nType_trait_tree = is_type_trait_tree(a::Expr)\nType_trait_tree = is_type_trait_tree(a::Number)\nType_not_trait_tree = is_type_trait_tree(a::Any)\n\nReturn a Type_trait_tree only for AbstractTree, Expr or Number (a leaf of a tree). In the other cases it returns Type_not_trait_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{ExpressionTreeForge.M_abstract_tree.AbstractTree}","page":"Reference","title":"Base.show","text":"show(tree::AbstractTree; deepth)\nshow(io::IO, tree::AbstractTree; deepth)\n\nPrint tree in the julia console with a suitable form.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.algo_tree.printer_tree","page":"Reference","title":"ExpressionTreeForge.algo_tree.printer_tree","text":"print_tree(tree::AbstractTree)\n\nPrint a tree as long as it satisfies the interface M_interface_tree.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ExpressionTreeForge.M_interface_tree._get_children-Tuple{ExpressionTreeForge.M_abstract_tree.AbstractTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_tree._get_children","text":"children = _get_children(tree)\n\nGet the children from the current node as part of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_tree._get_node-Tuple{ExpressionTreeForge.M_abstract_tree.AbstractTree}","page":"Reference","title":"ExpressionTreeForge.M_interface_tree._get_node","text":"node = _get_node(tree)\n\nGet the current node as a part of tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_tree.Type_node","page":"Reference","title":"ExpressionTreeForge.M_implementation_tree.Type_node","text":"Type_node{T} <: AbstractTree\n\nBasic implementation of a tree. A Type_node has fields:\n\nfield gathering the informations about the current node;\nchildren a vector of children, each of them being a Type_node.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_tree.equal_tree-Union{Tuple{T}, Tuple{ExpressionTreeForge.M_implementation_tree.Type_node{T}, ExpressionTreeForge.M_implementation_tree.Type_node{T}}} where T","page":"Reference","title":"ExpressionTreeForge.M_implementation_tree.equal_tree","text":"bool = equal_tree(tree1::Type_node{T}, tree2::Type_node{T})\n\nCheck recursively if every node is the same for both tree1 and tree2\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_abstract_tree.AbstractTree","page":"Reference","title":"ExpressionTreeForge.M_abstract_tree.AbstractTree","text":"Supertype of every tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_abstract_tree.create_tree-Tuple{ExpressionTreeForge.M_abstract_tree.AbstractTree}","page":"Reference","title":"ExpressionTreeForge.M_abstract_tree.create_tree","text":"tree = create_tree(field::T, children::Vector{Type_node{T}}) where {T}\ntree = create_tree(field::T, children::Array{Any, 1}) where {T}\ntree = create_tree(ex::Expr)\n\nCreate a tree of type Type_node from a field for the current node and its children or from an Expr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.Type_not_type_expr","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.Type_not_type_expr","text":"Type instantiated dynamically that checks if an argument is not a Type_expr_basic\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.Type_type_expr","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.Type_type_expr","text":"Type instantiated dynamically that checks if an argument is a Type_expr_basic\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_constant-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_constant","text":"bool = _is_constant(type)\n\nReturn true if type is a constant type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_cubic-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_cubic","text":"bool = _is_cubic(type)\n\nReturn true if type is a cubic type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_linear-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_linear","text":"bool = _is_linear(type)\n\nReturn true if type is a linear type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_more-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_more","text":"bool = _is_more(type)\n\nReturn true if type is more non linear than a cubic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_quadratic-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_quadratic","text":"bool = _is_quadratic(type)\n\nReturn true if type is a quadratic type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.is_trait_type_expr-Tuple{Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.is_trait_type_expr","text":"type = is_trait_type_expr(arg)\n\nReturn type::Type_type_expr if arg is an Type_expr_basic otherwise is return type::Type_not_type_expr\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.type_power-Tuple{Number, Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.type_power","text":"result_type = type_power(index, type)\n\nReturn the type resulting of type to power index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_trait_type_expr.type_product-Tuple{Any, Any}","page":"Reference","title":"ExpressionTreeForge.M_trait_type_expr.type_product","text":"result_type = type_product(type1, type2)\n\nReturn the type resulting of a product between type1 and type2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_constant-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_constant","text":"bool = _is_constant(type)\n\nReturn true if type is a constant type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_cubic-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_cubic","text":"bool = _is_cubic(type)\n\nReturn true if type is a cubic type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_linear-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_linear","text":"bool = _is_linear(type)\n\nReturn true if type is a linear type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_more-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_more","text":"bool = _is_more(type)\n\nReturn true if type is more non linear than a cubic type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_quadratic-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_quadratic","text":"bool = _is_quadratic(type)\n\nReturn true if type is a quadratic type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._type_power-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._type_power","text":"result_type = _type_power(index, type)\n\nReturn the type resulting of type to power index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._type_product-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._type_product","text":"result_type = _type_product(type1, type2)\n\nReturn the type resulting of a product between type1 and type2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_type_expr.return_constant-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_type_expr.return_constant","text":"constant = return_constant()\n\nReturn constantype::Type_expr_basic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_type_expr.return_cubic-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_type_expr.return_cubic","text":"cubic = return_cubic()\n\nReturn cubic::Type_expr_basic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_type_expr.return_linear-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_type_expr.return_linear","text":"linear = return_linear()\n\nReturn linear::Type_expr_basic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_type_expr.return_more-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_type_expr.return_more","text":"more = return_more()\n\nReturn more::Type_expr_basic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_type_expr.return_quadratic-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_type_expr.return_quadratic","text":"quadratic = return_quadratic()\n\nReturn quadratic::Type_expr_basic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_constant-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_constant","text":"bool = _is_constant(type::Type_expr_basic)\n\nCheck if type equals constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_cubic-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_cubic","text":"bool = _is_cubic(type::Type_expr_basic)\n\nCheck if type equals cubic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_linear-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_linear","text":"bool = _is_linear(type::Type_expr_basic)\n\nCheck if type equals linear.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_more-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_more","text":"bool = _is_more(type::Type_expr_basic)\n\nCheck if type equals more.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._is_quadratic-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._is_quadratic","text":"bool = _is_quadratic(type::Type_expr_basic)\n\nCheck if type equals quadratic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._type_power-Tuple{Number, ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._type_power","text":"result_type = _type_power(index_power::Number, b::Type_expr_basic)\n\nReturn result_type::Type_expr_basic, resulting of b^(index).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_interface_type_expr._type_product-Tuple{ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic, ExpressionTreeForge.M_implementation_type_expr.Type_expr_basic}","page":"Reference","title":"ExpressionTreeForge.M_interface_type_expr._type_product","text":"result_type = _type_product(a::Type_expr_basic, b::Type_expr_basic)\n\nReturn result_type::Type_expr_basic, the type resulting of the product a*b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.Convexity_type","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.Convexity_type","text":"Convexity_type\n\nType representing wether an expression is not_treated, constant, linear, convex, concave or unknown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper","text":"Convexity_wrapper\n\nWrapper around Convexity_type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.concave_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.concave_type","text":"concave = concave_type()\n\nReturn a concave::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.concave_wrapper-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.concave_wrapper","text":"concave_wrapper = concave_wrapper()\n\nReturn a Convexity_wrapper with value concave.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.constant_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.constant_type","text":"constant = constant_type()\n\nReturn a constant::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.constant_wrapper-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.constant_wrapper","text":"constant_wrapper = constant_wrapper()\n\nReturn a Convexity_wrapper with value constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.convex_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.convex_type","text":"convex = convex_type()\n\nReturn a convex::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.convex_wrapper-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.convex_wrapper","text":"convex_wrapper = convex_wrapper()\n\nReturn a Convexity_wrapper with value convex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.get_convexity_wrapper-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.get_convexity_wrapper","text":"convexity_status = get_convexity_wrapper(convexity::Convexity_wrapper)\n\nReturn the convexity status of convexity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.init_conv_status-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.init_conv_status","text":"untreated_wrapper = init_conv_status()\n\nReturn a Convexity_wrapper with value not_treated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_concave-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_concave","text":"bool = is_concave(status::Convexity_type)\nbool = is_concave(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals concave.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_constant-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_constant","text":"bool = is_constant(status::Convexity_type)\nbool = is_constant(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_convex-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_convex","text":"bool = is_convex(status::Convexity_type)\nbool = is_convex(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals convex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_linear-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_linear","text":"bool = is_linear(status::Convexity_type)\nbool = is_linear(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals linear.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_not_treated-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_not_treated","text":"bool = is_not_treated(status::Convexity_type)\nbool = is_not_treated(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals not_treated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_treated-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_treated","text":"bool = is_treated(status::Convexity_type)\nbool = is_treated(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals not_treated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.is_unknown-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.is_unknown","text":"bool = is_unknown(status::Convexity_type)\nbool = is_unknown(convexity::Convexity_wrapper)\n\nCheck if status or convexity.status equals unknown.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.linear_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.linear_type","text":"linear = linear_type()\n\nReturn a linear::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.linear_wrapper-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.linear_wrapper","text":"linear_wrapper = linear_wrapper()\n\nReturn a Convexity_wrapper with value linear.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.not_treated_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.not_treated_type","text":"not_treated = not_treated_type()\n\nReturn a not_treated::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.set_convexity_wrapper!-Tuple{ExpressionTreeForge.M_implementation_convexity_type.Convexity_wrapper, ExpressionTreeForge.M_implementation_convexity_type.Convexity_type}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.set_convexity_wrapper!","text":"set_convexity_wrapper!(convexity::Convexity_wrapper, t::Convexity_type)\n\nSet the convexity status of convexity to type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.unknown_type-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.unknown_type","text":"unknown = unknown_type()\n\nReturn a unknown::Convexity_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ExpressionTreeForge.M_implementation_convexity_type.unknown_wrapper-Tuple{}","page":"Reference","title":"ExpressionTreeForge.M_implementation_convexity_type.unknown_wrapper","text":"unknown_wrapper = unknown_wrapper()\n\nReturn a Convexity_wrapper with value unknown.\n\n\n\n\n\n","category":"method"},{"location":"#ExpressionTreeForge.jl","page":"Home","title":"ExpressionTreeForge.jl","text":"","category":"section"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExpressionTreeForge.jl is a manipulator of expression trees. It supports several expression tree implementations and defines methods to analyze and manipulate them, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"partial separability detection;\nevaluation of the expression, and its first and second derivatives;\nbound propagation;\nconvexity detection.","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia ≥ 1.6.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl\npkg> test ExpressionTreeForge","category":"page"},{"location":"#How-to-use","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the tutorial.","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module is used together with PartitionedStructures.jl by PartiallySeparableNLPModels.jl and PartiallySeparableSolvers.jl to define a trust-region method exploiting partial separability through partitioned quasi-Newton approximations. ","category":"page"},{"location":"tutorial/#ExpressionTreeForge.jl-Tutorial","page":"Tutorial","title":"ExpressionTreeForge.jl Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ExpressionTreeForge.jl analyzes and manipulates expression trees. It interfaces several implementations of expression trees to the internal type Type_expr_tree (with transform_to_expr_tree()).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main expression trees supported are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia Expr","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ExpressionTreeForge\nexpr_julia = :((x[1]+x[2])^2 + (x[2]+x[3])^2)\nexpr_tree_Expr = transform_to_expr_tree(expr_julia)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Expr from JuMP model (with MathOptInterface)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using JuMP, MathOptInterface\nm = Model()\nn = 3\n@variable(m, x[1:n])\n@NLobjective(m, Min, (x[1]+x[2])^2 + (x[2]+x[3])^2)\nevaluator = JuMP.NLPEvaluator(m)\nMathOptInterface.initialize(evaluator, [:ExprGraph])\nexpr_jump = MathOptInterface.objective_expr(evaluator)\nexpr_tree_JuMP = transform_to_expr_tree(expr_jump)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The both trees have the same sharpe","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"expr_tree_Expr == expr_tree_JuMP","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"expression tree from a julia function created by Symbolics.jl","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Symbolics\nfunction f(y)    \n  return sum((y[i] + y[i+1])^2 for i = 1:(length(y)-1))\nend\nn = 3\nSymbolics.@variables x[1:n] # must be x\n\nmtk_tree = f(x)\nexpr_tree_Symbolics = transform_to_expr_tree(mtk_tree)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which may perform automatically some simplifications or reorder the terms. However, expr_tree_Expr, expr_tree_JuMP and expr_tree_Symbolics share the same type ::Type_expr_tree:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With a Type_expr_tree, you can:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"detect partial separability;\nevaluate the expression, and its first and second derivatives;\npropagate bounds;\ndetect convexity.","category":"page"},{"location":"tutorial/#Detection-of-the-partially-separable-structure","page":"Tutorial","title":"Detection of the partially separable structure","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The original purpose of ExpressionTreeForge.jl is to detect the partially-separable structure of a function f  R^n to R","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = sum_=1^N hatf_i (U_i x) quad hat f_iR^n_i to R quad U_i in R^n_i times n quad n_i ll n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which means ExpressionTreeForge.jl detects that f is a sum, and returns:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the element functions hatf_i;\nthe variables appearing in hatf_i (i.e. elemental variables), which are represented via U_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You detect the element functions with extract_element_functions(), which returns a vector of Type_expr_trees:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"expr_tree = copy(expr_tree_Expr)\nelement_functions = extract_element_functions(expr_tree)\nshow(element_functions[2])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Warning: the element_functions are pointers to nodes of expr_tree. Any modification to element_functions will be applied to expr_tree!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You extract the elemental variables by applying get_elemental_variables() on every element function expression tree","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Us = get_elemental_variables.(element_functions)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you can replace the index variables of an element function expression tree so they stay in the range 1:length(Us[i]):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# change the indices of the second element function\nnormalize_indices!(element_functions[2], Us[2])","category":"page"},{"location":"tutorial/#Evaluate-a-Type_expr_tree-and-its-derivatives","page":"Tutorial","title":"Evaluate a Type_expr_tree and its derivatives","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ExpressionTreeForge.jl offers methods to evaluate an expression tree and its derivatives. evaluate_expr_tree() evaluates a Type_expr_tree at a point y of suitable size:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"y = ones(n)\nfx = expr_tree_Expr(y)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The gradient computation of an expression tree can either use ForwardDiff or ReverseDiff","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f_forward = gradient_forward(expr_tree_Expr, y)\n∇f_reverse = gradient_reverse(expr_tree_Expr, y)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gradient_forward == gradient_reverse","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the Hessian is computed with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hess = hessian(expr_tree_Expr, y)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AD methods can be applied to the element-function expression trees:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"y1 = ones(length(Us[1]))\nf1 = element_functions[1]\nf1x = evaluate_expr_tree(f1, y1)\n\n∇f1_forward = gradient_forward(f1, y1)\n∇f1_reverse = gradient_reverse(f1, y1)\n\nhess1 = hessian(f1, y1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See PartitionedStructures.jl for more details about partial separability and how the partitioned derivatives of the element functions are stored.","category":"page"},{"location":"tutorial/#Bounds-and-convexity","page":"Tutorial","title":"Bounds and convexity","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To compute bounds and convexity we use a Complete_expr_tree, a richer structure than Type_expr_tree. Complete_expr_tree is similar to Type_expr_tree, but in addition it stores: the lower bound, the upper bound and the convexity status of each node. You can define a Complete_expr_tree for any Type_expr_tree:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"completetree = complete_tree(expr_tree_Expr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You compute the bounds and the convexity status afterward","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# propagate the bounds from the variables\nset_bounds!(completetree)\n# deduce the convexity status of each node\nset_convexity!(completetree)\n# get the root bounds\nbounds = get_bounds(completetree)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# get the root convexity status\nconvexity_status = get_convexity_status(completetree)\nis_convex(convexity_status)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can observe the bounds and convexity status of each node of completetree by walking the graph","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# convexity statuses of the root's children\nstatuses = get_convexity_status.(completetree.children) \n# bounds of the root's children\nbounds = get_bounds.(completetree.children)","category":"page"}]
}
